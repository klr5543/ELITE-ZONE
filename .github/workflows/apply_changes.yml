name: Apply Daleel Bot Changes

# Trigger manually from the Actions tab
on:
  workflow_dispatch:

permissions:
  contents: write  # allow the Action to commit to the repository

jobs:
  apply-files:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      - name: Ensure directories
        run: |
          mkdir -p utils
          mkdir -p cogs

      - name: Write bot.py
        run: |
          cat > bot.py <<'EOF'
# بوت "دليل" - ملف واحد شامل للاستخدام الفوري
# انسخ هذا الملف كاملًا واستبدل به bot.py في مشروعك، ثم شغّل.
# ملاحظات: يحتاج مجلد arcraiders-data/ جنب هذا الملف ليعمل البحث المحلي.
# يعتمد على discord.py v2.x و python-dotenv. rapidfuzz اختياري لتحسين المطابقة.

import os
import re
import json
import logging
import asyncio
from pathlib import Path
from functools import lru_cache
from difflib import SequenceMatcher
from typing import Optional, Tuple, List

import discord
from discord.ext import commands
from discord import app_commands
from dotenv import load_dotenv

# Optional fast fuzzy library — أفضل من SequenceMatcher إن توفّر
try:
    from rapidfuzz import fuzz
    HAS_RAPIDFUZZ = True
except Exception:
    HAS_RAPIDFUZZ = False

# -------------------------
# إعداد البيئة والمتغيرات
# -------------------------
load_dotenv()

DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")
ALLOWED_GUILD_ID = int(os.getenv("ALLOWED_GUILD_ID", "621014916173791288"))
OWNER_ID = int(os.getenv("OWNER_ID", "595228721946820614"))

BOT_NAME = "دليل"
BOT_VERSION = "2.0.3"

# -------------------------
# إعداد logging
# -------------------------
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("daleel-bot")

# -------------------------
# قواميس ترجمة عربية->إنجليزية بسيطة (قابلة للتوسيع)
# -------------------------
ARABIC_TO_ENGLISH = {
    'سلاح': 'weapon',
    'اسلحة': 'weapons',
    'بندقية': 'rifle',
    'مسدس': 'pistol',
    'رشاش': 'smg',
    'قناص': 'sniper',
    'شوتقن': 'shotgun',
    'مخطط': 'blueprint',
    'مخطوطة': 'blueprint',
    'تصنيع': 'craft',
    'طاولة': 'workbench',
    'ادوات': 'materials',
    'أدوات': 'materials',
    'قطع': 'parts',
    'قطع غيار': 'parts',
    'مكونات': 'components',
    'كيف احصل': 'how to get',
    'كيفية الحصول': 'how to get',
}

# -------------------------
# مسارات البيانات
# -------------------------
BASE_DIR = Path(__file__).parent
DATA_DIR = BASE_DIR / "arcraiders-data"

# -------------------------
# أدوات مساعدة للنصوص والبحث
# -------------------------
def normalize_text(s: Optional[str]) -> str:
    if not s:
        return ""
    s = str(s).lower()
    s = re.sub(r"[^\w\s\u0600-\u06FF\-]", " ", s)
    s = re.sub(r"\s+", " ", s).strip()
    return s

def translate_arabic_tokens(text: str) -> str:
    tokens = text.split()
    out = []
    for t in tokens:
        out.append(ARABIC_TO_ENGLISH.get(t, t))
    return " ".join(out)

def similarity_score(a: str, b: str) -> float:
    if HAS_RAPIDFUZZ:
        try:
            return fuzz.token_sort_ratio(a, b) / 100.0
        except Exception:
            return SequenceMatcher(None, a, b).ratio()
    else:
        return SequenceMatcher(None, a, b).ratio()

# -------------------------
# DataLoader: تحميل وفهرسة JSON محليًا
# -------------------------
class DataLoader:
    def __init__(self, data_dir: Path):
        self.data_dir = data_dir
        self._data = {}
        self._index = []  # list of (source_file, obj, [name_variants_normalized])
        self._load_all()

    def _load_all(self):
        if not self.data_dir.exists():
            logger.warning("مجلد البيانات لم يُوجد: %s", self.data_dir)
            return
        files = list(self.data_dir.glob("*.json"))
        for f in files:
            try:
                txt = f.read_text(encoding="utf-8")
                content = json.loads(txt)
                self._data[f.stem] = content
                if isinstance(content, list):
                    for obj in content:
                        names = []
                        name_field = obj.get("name")
                        if isinstance(name_field, dict):
                            for v in name_field.values():
                                names.append(str(v))
                        elif isinstance(name_field, str):
                            names.append(name_field)
                        if "id" in obj and obj.get("id"):
                            names.append(str(obj.get("id")))
                        if "displayName" in obj:
                            names.append(str(obj.get("displayName")))
                        if "title" in obj:
                            names.append(str(obj.get("title")))
                        names_normalized = [normalize_text(n) for n in names if n]
                        if names_normalized:
                            self._index.append((f.stem, obj, names_normalized))
                else:
                    pass
            except Exception as e:
                logger.exception("فشل تحميل ملف JSON %s: %s", f, e)
        logger.info("DataLoader: حمل %d ملفات JSON وفهرس %d عنصر", len(self._data), len(self._index))

    @lru_cache(maxsize=128)
    def find_best_match(self, query: str, min_ratio: float = 0.65) -> Optional[Tuple[str, dict, float]]:
        q = normalize_text(query)
        q_trans = normalize_text(translate_arabic_tokens(q))
        best = None
        best_score = 0.0
        if len(q) <= 3:
            min_ratio = max(min_ratio, 0.8)
        for source, obj, names in self._index:
            for n in names:
                s1 = similarity_score(q, n)
                s2 = similarity_score(q_trans, n)
                score = max(s1, s2)
                if score > best_score:
                    best_score = score
                    best = (source, obj, score)
        if best and best_score >= min_ratio:
            return best
        return None

    def find_top_matches(self, query: str, limit: int = 5) -> List[Tuple[str, dict, float]]:
        q = normalize_text(query)
        q_trans = normalize_text(translate_arabic_tokens(q))
        scored = []
        for source, obj, names in self._index:
            for n in names:
                s1 = similarity_score(q, n)
                s2 = similarity_score(q_trans, n)
                score = max(s1, s2)
                scored.append((score, source, obj))
        scored.sort(reverse=True, key=lambda x: x[0])
        results = []
        for score, source, obj in scored[:limit]:
            results.append((source, obj, score))
        return results

    def raw(self, name: str):
        return self._data.get(name)

# -------------------------
# بناء الردود (مختصر + تفصيلي)
# -------------------------
def safe_get_display_name(item: dict) -> str:
    name = item.get("name")
    if isinstance(name, dict):
        return name.get("ar") or name.get("en") or next(iter(name.values()))
    return name or item.get("id") or "معلومة"

def build_short_answer(source: str, item: dict) -> str:
    display = safe_get_display_name(item)
    parts = [f"**{display}**"]
    found = item.get("foundIn") or item.get("maps") or item.get("location")
    if found:
        if isinstance(found, (list, tuple)):
            parts.append(f"تحصل عليه في: {', '.join(str(x) for x in found[:3])}")
        else:
            parts.append(f"تحصل عليه في: {found}")
    price = item.get("value") or item.get("price") or item.get("cost")
    if price:
        parts.append(f"السعر: {price}")
    return " · ".join(parts)

def build_full_embed(source: str, item: dict) -> discord.Embed:
    title = safe_get_display_name(item)
    descr = ""
    name_field = item.get("name")
    if isinstance(name_field, dict):
        descr = item.get("description") or name_field.get("ar") or name_field.get("en") or ""
    else:
        descr = item.get("description") or ""
    embed = discord.Embed(title=str(title), description=str(descr) or None, color=0x2F3136)
    if item.get("foundIn"):
        embed.add_field(name="المكان", value=str(item.get("foundIn")), inline=False)
    if item.get("maps"):
        maps = item.get("maps")
        if isinstance(maps, (list, tuple)):
            embed.add_field(name="الخرائط", value=", ".join(maps[:8]), inline=False)
    price = item.get("value") or item.get("price") or item.get("cost")
    if price:
        embed.add_field(name="السعر / التكلفة", value=str(price), inline=True)
    if item.get("drops"):
        drops = item.get("drops")
        if isinstance(drops, (list, tuple)):
            embed.add_field(name="أسقاطات (drops)", value=", ".join(drops[:20]), inline=False)
    if item.get("recipe") or item.get("craft"):
        embed.add_field(name="وصفة / تصنيع", value=str(item.get("recipe") or item.get("craft")), inline=False)
    embed.set_footer(text=f"مصدر: {source} · {BOT_NAME} v{BOT_VERSION}")
    return embed

# -------------------------
# Discord bot (single-file)
# -------------------------
intents = discord.Intents.default()
intents.message_content = True

bot = commands.Bot(command_prefix="!", intents=intents)

bot.data_loader: Optional[DataLoader] = None

class DetailsView(discord.ui.View):
    def __init__(self, embed: discord.Embed, timeout: int = 120):
        super().__init__(timeout=timeout)
        self.embed = embed

    @discord.ui.button(label="عرض التفاصيل", style=discord.ButtonStyle.primary, row=1)
    async def on_show(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_message(embed=self.embed)

class DisambButton(discord.ui.Button):
    def __init__(self, label: str, payload):
        super().__init__(label=label, style=discord.ButtonStyle.secondary)
        self.payload = payload

    async def callback(self, interaction: discord.Interaction):
        source, item, score = self.payload
        short = build_short_answer(source, item)
        embed = build_full_embed(source, item)
        view = DetailsView(embed)
        await interaction.response.send_message(content=short, embed=None, view=view)

class DisambiguationView(discord.ui.View):
    def __init__(self, options: List[Tuple[str, dict, float]], timeout: int = 60):
        super().__init__(timeout=timeout)
        for i, (source, item, score) in enumerate(options[:5]):
            label = safe_get_display_name(item)
            self.add_item(DisambButton(label=label, payload=(source, item, score)))

@bot.event
async def on_ready():
    logger.info("Logged in as %s (id=%s)", bot.user, bot.user.id)
    bot.data_loader = DataLoader(DATA_DIR)

@commands.command(name="سأل")
async def ask_prefix(ctx: commands.Context, *, query: str):
    await handle_query_common(ctx, query)

bot.add_command(ask_prefix)

@bot.tree.command(name="سأل", description="اسأل عن عنصر أو عن طريقة الحصول عليه")
@app_commands.describe(query="اكتب اسم العنصر أو السؤال")
async def ask_slash(interaction: discord.Interaction, query: str):
    await interaction.response.defer()
    await handle_query_common(interaction, query)

async def handle_query_common(ctx_or_inter, **kwargs):
    query = kwargs.get('query', '')
    loader: DataLoader = bot.data_loader
    if loader is None:
        return await _respond_from_context(ctx_or_inter, content="خطأ: DataLoader غير محمّل.")
    exact = loader.find_best_match(query, min_ratio=0.7)
    if exact:
        source, item, score = exact
        short = build_short_answer(source, item)
        embed = build_full_embed(source, item)
        view = DetailsView(embed)
        await _respond_from_context(ctx_or_inter, content=short, embed=None, view=view)
        return
    top = loader.find_top_matches(query, limit=5)
    top_filtered = [t for t in top if t[2] >= 0.45]
    if top_filtered:
        msg = "ما حصلت تطابق قوي، بس هذي ممكن تكون المقصودة. اضغط على الخيار المناسب:"
        view = DisambiguationView(top_filtered)
        await _respond_from_context(ctx_or_inter, content=msg, view=view)
        return
    await _respond_from_context(ctx_or_inter, content="ما فهمت اسم واضح. تقدر توضّح أكثر؟")

async def _respond_from_context(ctx_or_inter, **kwargs):
    if isinstance(ctx_or_inter, commands.Context):
        return await ctx_or_inter.send(**kwargs)
    elif isinstance(ctx_or_inter, discord.Interaction):
        try:
            if ctx_or_inter.response.is_done():
                return await ctx_or_inter.followup.send(**kwargs)
            else:
                return await ctx_or_inter.response.send_message(**kwargs)
        except Exception:
            return await ctx_or_inter.followup.send(**kwargs)
    else:
        raise TypeError("Unsupported context type")

def main():
    if not DISCORD_TOKEN:
        logger.error("DISCORD_TOKEN غير مضبوط.")
        return
    try:
        bot.run(DISCORD_TOKEN)
    except Exception as e:
        logger.exception("فشل تشغيل البوت: %s", e)

if __name__ == "__main__":
    main()
EOF

      - name: Write utils/data_loader.py
        run: |
          cat > utils/data_loader.py <<'EOF'
# Simple DataLoader to read JSON files from arcraiders-data and provide a find_best_match function.
import json
from pathlib import Path
from difflib import SequenceMatcher
from functools import lru_cache
import re
import logging

logger = logging.getLogger("daleel-bot.data_loader")

BASE_DIR = Path(__file__).parent.parent
DATA_DIR = BASE_DIR / "arcraiders-data"

ARABIC_TO_ENGLISH = {
    'سلاح': 'weapon',
    'اسلحة': 'weapons',
    'بندقية': 'rifle',
    'مسدس': 'pistol',
    'رشاش': 'smg',
    'قناص': 'sniper',
    'شوتقن': 'shotgun',
    'مخطط': 'blueprint',
    'مخطوطة': 'blueprint',
    'تصنيع': 'craft',
    'طاولة': 'workbench',
    'ادوات': 'materials',
    'أدوات': 'materials',
}

def normalize_text(s: str) -> str:
    if not s:
        return ""
    s = s.lower()
    s = re.sub(r"[^\w\s\u0600-\u06FF\-]", " ", s)
    s = re.sub(r"\s+", " ", s).strip()
    return s

class DataLoader:
    def __init__(self):
        self._data = {}
        self._items_index = []
        self._load_all_json()

    def _load_all_json(self):
        if not DATA_DIR.exists():
            logger.warning("arcraiders-data not found")
            return
        for f in DATA_DIR.glob("*.json"):
            try:
                txt = f.read_text(encoding="utf-8")
                data = json.loads(txt)
                self._data[f.stem] = data
                if isinstance(data, list):
                    for obj in data:
                        names = []
                        name_field = obj.get("name")
                        if isinstance(name_field, dict):
                            for v in name_field.values():
                                names.append(str(v))
                        elif isinstance(name_field, str):
                            names.append(name_field)
                        if "id" in obj and obj.get("id"):
                            names.append(str(obj.get("id")))
                        names_normalized = [normalize_text(n) for n in names if n]
                        if names_normalized:
                            self._items_index.append((f.stem, obj, names_normalized))
            except Exception as e:
                logger.exception("Failed loading %s: %s", f, e)

    @lru_cache(maxsize=128)
    def find_best_match(self, query: str, min_ratio: float = 0.65):
        q = normalize_text(query)
        if not q:
            return None
        best = None
        best_score = 0.0
        for source, obj, names in self._items_index:
            for n in names:
                s = SequenceMatcher(None, q, normalize_text(n)).ratio()
                if s > best_score:
                    best_score = s
                    best = (source, obj, s)
        if best and best_score >= min_ratio:
            return best
        return None
EOF

      - name: Write cogs/qa_compact.py
        run: |
          cat > cogs/qa_compact.py <<'EOF'
# Cog that answers queries concisely and provides a "عرض التفاصيل" button.
# Placeholder cog for modular project structure.
from discord.ext import commands
import discord

class QACompact(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command(name="سأل")
    async def ask(self, ctx, *, query: str):
        await ctx.send("بوّت: إجابة مختصرة هنا — اضغط عرض التفاصيل")
EOF

      - name: Update requirements.txt
        run: |
          cat > requirements.txt <<'EOF'
discord.py==2.3.2
python-dotenv==1.0.0
aiohttp==3.9.4
rapidfuzz==2.3.0
EOF

      - name: Commit changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add bot.py utils/data_loader.py cogs/qa_compact.py requirements.txt || true
          git commit -m "Apply Daleel bot files: bot.py, utils, cogs, requirements" || echo "No changes to commit"
          git push origin HEAD:main || echo "Push failed (maybe protected branch)"
